%Este trabalho está licenciado sob a Licença Creative Commons Atribuição-CompartilhaIgual 3.0 Não Adaptada. Para ver uma cópia desta licença, visite https://creativecommons.org/licenses/by-sa/3.0/ ou envie uma carta para Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

\chapter{Rápida introdução à linguagem Julia}\label{cap:julia}\index{Julia}

Neste apêndice, abordaremos a linguagem computacional \verb+Julia+ que nos auxiliará no processo de obtenção de resultados de operações e computações utilizando o computador.

\section{Sobre a linguagem Julia}\index{Julia!sobre}

A linguagem de programação Julia é uma linguagem moderna e poderosa que foi criada para atender aos requisitos da computação numérica de alto desempenho e científica.
Seus criadores quiseram reunir na linguagem as principais (melhores) características de outras linguagens:

\begin{itemize}
\item Ruby;
\item matlab;
\item R;
\item Julia;
\item C.
\end{itemize}

\href{https://julialang.org/}{Julia} é uma linguagem de programação de alto nível, interpretada e multi-paradigma. 

Para mais informações, consulte:

\begin{itemize}
\item Página oficial da linguagem Julia: \url{https://julialang.org/}
\item Manual Julia: \url{https://docs.julialang.org/en/v1/manual/getting-started/}
\item GitHub do Professor Daniel: \url{https://github.com/Daniel-C-Fernandes/Numerico/blob/main/Mini-curso-Julia.ipynb}
\item Julia for Data science: \url{https://juliadatascience.io/pt/}
\item Julia Academy: \url{https://juliaacademy.com/}
\item GitHub Julia: \url{https://github.com/JuliaLang/julia}
\item Introdução: \url{https://julia.vento.eng.br/}
\item Curso Julia USP: \url{https://edisciplinas.usp.br/pluginfile.php/7879038/mod_resource/content/4/Tutorial%20para%20a%20Linguagem%20Julia.pdf}
\item Tutoriais Julia: \url{https://julialang.org/learning/tutorials/}
\end{itemize}

Para saber mais: \url{https://www.youtube.com/watch?v=Xzdg9czOxD8&t=29s}

\subsection{Características Principais}

\begin{itemize}
\item \textbf{Tipagem Dinâmica:} Suas variáveis podem receber qualquer tipo de dado, e sua sintaxe se aproxima mais da linguagem humana do que da linguagem de máquina.

\item \textbf{Multiparadigma:} Suporta diversos paradigmas de programação, como orientação a objetos e programação funcional.

\item \textbf{Alto Nível:} Possui uma sintaxe expressiva e amigável.

\item \textbf{Gratuita e Open Source:} Julia é distribuída sob a licença MIT.

\item \textbf{Suporte a Unicode e UTF-8:} Permite o uso de símbolos matemáticos durante a escrita de programas. Gerenciador de Pacotes Prático: Facilita a instalação e atualização de pacotes.
\end{itemize}

Aplicações:

\begin{itemize}
\item \textbf{Data Science:} Julia é usada para análise de dados e descoberta de conhecimento a partir de grandes conjuntos de dados. Machine Learning: Possui pacotes poderosos para criação de modelos de aprendizado de máquina.

\item \textbf{Computação Científica:} Ideal para construir modelos matemáticos e soluções numéricas.

\item \textbf{Desenvolvimento Geral:} Pode ser aplicada no desenvolvimento de aplicações web, desktop e outras áreas. Em resumo, Julia é uma linguagem versátil que combina alta performance com uma sintaxe amigável, tornando-a uma escolha popular entre cientistas de dados, desenvolvedores e entusiastas da programação.
\end{itemize}

Visão geral sobre linguagens de programação: Qual a melhor linguagem de programação? Veja \url{https://www.youtube.com/watch?v=DjUB-yVWT2A}.

Para iniciantes, recomendamos o curso EAD gratuito no site \href{https://www.youtube.com/watch?v=0oChN11wf_4}{Goggo dot jl}:
\begin{center}
  \url{https://www.youtube.com/watch?v=0oChN11wf_4}
\end{center}

\subsection{Instalação e execução}\index{Julia!instalação e execução}

Para versões \verb+Linux+ \verb+Ubuntu+ ou \verb+Debian+, basta utilizar o comando a seguir e esperar a instalação:
\begin{lstlisting}[style=c]
> sudo apt install julia -y
\end{lstlisting}

Para versões \verb+Windows+, utilize o Prompt de comando \verb+PowerShell+ para inserir o comando de instalação a seguir:
\begin{lstlisting}[style=c]
> winget install julia -s msstore
\end{lstlisting}

Execute o modo interativo da linguagem \verb+Julia+ simplesmente digitando o nome da linguagem seguida de Enter:

\begin{lstlisting}[style=c]
> julia
\end{lstlisting}

Dessa forma, abre-se o interpretador interativo da linguagem \verb+Julia+. Pode-se então, como primeira interação, realizar uma operação matemática:

\begin{lstlisting}
julia> 2 + 3
5
\end{lstlisting}

No \href{https://julialang.org/downloads/}{site oficial da linguagem Julia} estão disponíveis para {\it download} os interpretadores para os principais sistemas operacionais, \verb+Linux+, \verb+Mac OS+ e \verb+Windows+. 

Além disso, no \href{https://github.com/Daniel-C-Fernandes/Numerico/tree/main}{GitHub do professor Daniel}, há um tutorial de instalação para a versão Windows do intepretador de linguagem \verb+Julia+ juntamente com o ambiente \verb+Jupyter Notebook+ e uma \href{https://github.com/Daniel-C-Fernandes/Numerico/blob/main/Mini-curso-Julia.ipynb}{introdução à linguagem de programação com exemplos}.

\subsection{Usando Julia}\index{Julia!usando}

O uso da linguagem \verb+Julia+ pode ser feito de três formas básicas:

\begin{itemize}
\item usando um {\bf console Julia} de modo interativo;
\item executando um código \verb+codigo.jl+ no console \verb+Julia+;
\item executando um código \verb+Julia+ \verb+codigo.jl+ diretamente no terminal;
\end{itemize}

\subsubsection{Execução no terminal de um código salvo em .jl}

Para se executar um código diretamente no terminal de comando do sistema operacional, basta escrevermos o código que desejamos em um arquivo texto de extensão \emph{.jl}.

Dessa forma, por exemplo, salvaremos o seguinte código num arquivo chamado \emph{ola.jl}:

\begin{lstlisting}
  println("Hello world!!")
\end{lstlisting}

Após o salvamento, estando o prompt de comando no mesmo diretório do arquivo salvo, basta executarmos o seguinte comando, obtendo-se a resposta que se segue:

\begin{lstlisting}[style=c]
> julia ola.jl
Hello world!!
\end{lstlisting}

\subsubsection{Utilização do Console interativo Julia}

Para executarmos qualquer comando no console interativo da linguagem \verb+Julia+, iniciaremos o console interativo da seguinte forma:

\begin{lstlisting}[style=c]
> julia
\end{lstlisting}

Estando o modo interativo rodando no prompt de comando, basta inserirmos o comando desejado e verificar o resultado da saída do comando registrado na linha seguinte do prompt:

\begin{lstlisting}
julia> println("Hello world!!")
Hello world!!
\end{lstlisting}

\subsubsection{Execução no console de um código salvo em .jl}

Para executarmos qualquer um código salvo com extensão \emph{.jl} no console interativo da linguagem \verb+Julia+, iniciaremos o console interativo da seguinte forma:

\begin{lstlisting}[style=c]
> julia
\end{lstlisting}

Estando o modo interativo rodando no prompt de comando, basta inserirmos o seguinte comando e verificar o resultado da saída do arquivo registrado na linha seguinte do prompt (observe que o arquivo deve estar localizado em ...):

\begin{lstlisting}
julia> include ola.jl
Hello world!!
\end{lstlisting}

\section{Elementos da linguagem}\index{Julia!elementos da linguagem}

\verb+Julia+ é uma linguagem de alto nível de tipagem dinâmica, ou seja, uma variável é criada quando um valor é atribuído a ela, não sendo necessário especificar explicitamente cada tipo de variável, \verb+Julia+ vai inferir o tipo de cada variável por você. Porém, também é possível especificar a declaração da variável a ser criada, se for desejável.

\subsection{Variáveis}

Variáveis são valores armazenados pelo computador atrelados a um nome específico, para seja possível recuperar ou alterar seu valor posteriormente. 

Alguns tipos de variáveis em \verb+Julia+:

\begin{itemize}
\item Números inteiros: Int64
\item Números reais: Float64
\item Matrizes inteiras: Matrix\{Int64\}
\item Matrizes reais: Matrix\{Float64\}
\item Booleanas: Bool
\item Strings: String
\end{itemize}

Por padrão, números são armazenados usando 64 bits, sendo possível aumentar ou reduzir a precisão, utilizando os tipos Int8 ou Int128, por exemplo.



























Criamos novas variáveis escrevendo o nome da variável à esquerda e seu valor à direita, e no meio usamos o operador de atribuição =.

Vejamos alguns exemplos:

\begin{lstlisting}
julia> x = 1
1
julia> y = x * 2.0
2.0
\end{lstlisting}



variaveis com emogi




a variável \verb+x+ recebe o valor \verb+int+ $1$ e, logo após, na segunda linha de comando, a variável \verb+y+ recebe o valor \verb+double+ $2$. Observamos que o símbolo \verb+=+ significa o operador de atribuição não o de igualdade. O operador lógico de igualdade no \verb+Julia+ é \verb+==+. Veja os seguintes comandos:

\begin{lstlisting}
julia> print(x, "-", y)
1-2.0

julia> typeof(x), typeof(y)
(Int64, Float64)
\end{lstlisting}

Comentários e continuação de linha de comando são usados como no seguinte exemplo:

\begin{lstlisting}
julia> # Isto é um comentário

julia> x = 1
1

julia> print(x)
1
\end{lstlisting}





Utilizando Julia como calculadora....




































\section{Repositórios}

Tartaruga 

OhMyREPL:
add OhMyREPL
using OhMyREPL

Criar arquivo:
.julia/config/startup.jl
using OhMyREPL





\section{Estruturas de ramificação e repetição}\index{Julia!ramificação e repetição}

A linguagem \verb+Julia+ contém estruturas de repetição e ramificação padrões de linguagens estruturadas.

\subsection{A instrução de ramificação ``if''}\index{Julia!if}

A instrução ``if'' permite executar um pedaço do código somente se uma dada condição for satisfeita.

\begin{ex}
  Veja o seguinte código Julia:
\begin{lstlisting}
#!/usr/bin/env Julia
# -*- coding: utf-8 -*-

i = 2
if (i == 1):
    print("Olá!")
elif (i == 2):
    print("Hallo!")
elif (i == 3):
    print("Hello!")
else:
    print("Ça Va!")
\end{lstlisting}
Qual é a saída apresentada pelo código? Por quê?
\end{ex}

Observamos que, em \verb+Julia+, a identação é obrigatória, pois é ela que defini o escopo da instrução.

\subsection{A instrução de repetição ``for''}\index{Julia!for}

A instrução \verb+for+ permite que um pedaço de código seja executado repetidamente.

\begin{ex}
  Veja o seguinte código:
\begin{lstlisting}
for i in range(6):
    print(i)
\end{lstlisting}
Qual é a saída deste código? Por quê?
\end{ex}

\begin{ex}
  Veja o seguinte código:
\begin{lstlisting}
import numpy as np
for i in np.arange(1,8,2):
    print(i)
\end{lstlisting}
Qual é a saída deste código? Por quê?
\end{ex}

\begin{ex}
  Veja o seguinte código:
\begin{lstlisting}
for i in np.arange(10,0,-3):
  print(i)
\end{lstlisting}
O que é mostrado no console do Julia?
\end{ex}

\begin{ex}
  Veja o seguinte código:
\begin{lstlisting}
import numpy as np
for i in np.arange(10,1,-3):
    print(i)
\end{lstlisting}
O que é mostrado no console do Julia?
\end{ex}

\subsection{A instrução de repetição ``while''}\index{Julia!while}

A instrução \verb+while+ permite que um pedaço de código seja executado repetidamente até que uma dada condição seja satisfeita.

\begin{ex}
Veja o seguinte código Julia:
\begin{lstlisting}
s = 0
i = 1
while (i <= 10):
    s = s + i
    i = i + 1
\end{lstlisting}
Qual é o valor de \verb+s+ ao final da execução? Por quê?
\end{ex}

\section{Funções}\index{Julia!funções}

Além das muitas funções disponíveis em \verb+Julia+ (e os tantos muitos pacotes livres disponíveis), podemos definir nossas próprias funções. Para tanto, existe a instrução \verb+def+. Veja os seguintes exemplos:

\begin{ex}
  O seguinte código:
\begin{lstlisting}
def f(x):
    return x + np.sin(x)
\end{lstlisting}
define a função $f(x) = x + \sen x$.

Observe que $f(\pi) = \pi$. Confirme isso computando:
\begin{lstlisting}
>>> f(np.pi)
\end{lstlisting}
\end{ex}

\begin{ex}
  O seguinte código em \verb+Julia+:
\begin{lstlisting}
def h(x,y):
    if (x < y):
        return y - x
    else:
        return x - y
\end{lstlisting}
define a função:
\begin{equation}
  h(x,y) = \left\{
    \begin{array}{ll}
      y - x &, x < y\\
      x - y &, x \geq y
    \end{array}
\right.
\end{equation}
\end{ex}

\begin{ex}
  O seguinte código:
\begin{lstlisting}
def J(x):
    y = np.zeros((2,2))
    y[0,0] = 2*x[0]
    y[0,1] = 2*x[1]

    y[1,0] = -x[1]*np.sin(x[0]*x[1])
    y[1,1] = -x[0]*np.sin(x[0]*x[1])

    return y
\end{lstlisting}
define a matriz jacobiana $J(x_1,x_2) := \frac{(f_1,f_2)}{(x_1,x_2)}$ da função:
\begin{equation}
  \pmb{f}(x_1,x_2) = (x_1^2 + x_2^2,~\cos(x_1x_2)).
\end{equation}
\end{ex}





















\subsection{Operações matemáticas elementares}\index{Julia!operações matemáticas}

Em \verb+Julia+, os operadores matemáticos elementares são os seguintes:
\begin{lstlisting}[mathescape=true]
  + # adição
  - # subtração
  * # multiplicação
  / # divisão de a por b
  \ # divisão de b por a
  % # Resto da divisão euclidiana
  $\div$ # Quociente inteiro da divisão euclidiana (alt + 246)
  (ou \div + tab)
  ^ #potenciação
  // # Frações
  exp() #potenciação de base e
  Log() #Logarítimo Neperiano
  Log10() #Logarítimo de base 10
\end{lstlisting}

\subsection{Funções e constantes elementares}\index{Julia!funções e constantes (math)}

Várias funções e constantes elementares estão disponíveis no pacote módulo Julia \href{https://docs.Julia.org/3/library/math.html?highlight=math#module-math}{math}. Por exemplo:
\begin{lstlisting}[mathescape=true]
julia> $\pi$  = pi (\pi + tab)
$\pi$ = 3.1415926535897...

julia> cos($\pi$)
-1.0

julia> exp(1)
2.718281828459045

julia> log(exp(1))
1.0
\end{lstlisting}

Observamos que \verb+log+ é a função logaritmo natural, isto é, $f(x) = \ln(x)$, enquanto que a implementação Julia de $f(x) = \log(x)$ é:

\begin{lstlisting}
julia> log10(10)
1.0
\end{lstlisting}

Veja mais na documentação \href{https://julia-doc-pt-br.readthedocs.io/en/latest/manual/mathematical-operations.html}{Julia}.

\subsection{Operadores lógicos}\index{Julia!operadores lógicos}

Em \verb+Julia+, o valor lógico verdadeiro é escrito como \verb+True+ e o valor lógico falso como \verb+False+. Temos os seguintes operadores lógicos disponíveis:
\begin{lstlisting}
&&  # e lógico
||  # ou lógico
!  # negação
== # igualdade
!= # diferente
<  # menor que
>  # maior que
<= # menor ou igual que
>= # maior ou igual que
\end{lstlisting}

Veja mais em \url{https://acervolima.com/operadores-em-julia/}.

\section{Matrizes}\index{Julia!matrizes (numpy)}

Em \verb+Julia+, temos um ótimo suporte para computação científica com o pacote \href{http://www.numpy.org/}{numpy}. Uma matriz $A = [a_{i,j}]_{i,j=1}^{m,n}$ em Julia é definida usando-se a seguinte sintaxe:
\begin{lstlisting}[mathescape=true]
julia> A = [
          $a_{11}$ $a_{12}$ $\dots$ $a_{1n}$,
          $a_{21}$ $a_{22}$ $\dots$ $a_{2n}$,
          $\vdots$
          $a_{m1}$ $a_{m2}$ $\dots$ $a_{mn}$
          ]
\end{lstlisting}

\begin{ex}
  Defina a matriz:
  \begin{equation}
    A = \left[
      \begin{array}{ccc}
        1 & 2 & 3\\
        4 & 5 & 6
      \end{array}
\right]
  \end{equation}
\end{ex}
\begin{sol}
  Em \verb+Julia+, digitamos:
\begin{lstlisting}[mathescape=true]
julia> A = [1 2 3,
            4 5 6]

julia> print(A)
2$\times$3 Matrix{Int64}:
1 2 3
4 5 6
\end{lstlisting}
\end{sol}

A seguinte lista contém uma série de funções que geram matrizes particulares:

\begin{lstlisting}
eye      # matriz identidade
linspace # vetor de elementos linearmente espaçados
ones     # matriz cheia de uns
zeros    # matriz nula
\end{lstlisting}

\subsection{Obtendo dados de uma matriz}

A função \verb+numpy.shape+ retorna o tamanho de uma matriz, por exemplo:
\begin{lstlisting}
>>> A = np.ones((3,2))
>>> print(A)
[[ 1.  1.]
 [ 1.  1.]
 [ 1.  1.]]
>>> nl, nc = np.shape(A)
>>> print(nl,nc)
(3, 2)
\end{lstlisting}
informando que a matriz \verb+A+ tem três linhas e duas colunas.

Existem vários métodos para acessar os elementos de uma matriz dada \verb+A+:
\begin{itemize}
\item a matriz inteira acessa-se com a sintaxe:
\begin{lstlisting}
A
\end{lstlisting}
\item o elemento da $i$-ésima linha e $j$-ésima coluna acessa-se usando a sintaxe:
\begin{lstlisting}
A[i,j]
\end{lstlisting}
\item o bloco formado pelas linhas $i_1$, $i_2$ e pelas colunas $j_1$, $j_2$ obtém-se usando a sintaxe:
\begin{lstlisting}
A[i1:i2, j1:j2]
\end{lstlisting}
\end{itemize}

\begin{ex}
  Veja as seguintes linhas de comando:
\begin{lstlisting}
>>> from numpy import random
>>> A = np.random.random((3,4))
>>> A
array([[ 0.39235668,  0.30287204,  0.24379253,  0.98866709],
       [ 0.72049734,  0.99300252,  0.14232844,  0.25604346],
       [ 0.61553036,  0.80615392,  0.22418474,  0.13685148]])
>>> A[2,3]
0.13685147547025989
>>> A[1:3,1:4]
array([[ 0.99300252,  0.14232844,  0.25604346],
       [ 0.80615392,  0.22418474,  0.13685148]])
\end{lstlisting}
\end{ex}

Definida uma matriz $A$ em Julia, as seguintes sintaxes são bastante úteis:
\begin{lstlisting}
A[:,:]   toda a matriz
A[i:j,k] os elementos das linhas i até j (exclusive) da k-ésima coluna
A[i,j:k] os elementos da i-ésima linha das colunas j até k (exclusive)
A[i,:]   a i-ésima linha da matriz
A[:,j]   a j-ésima coluna da matriz
\end{lstlisting}

Atenção, os índices em \verb+Julia+ iniciam-se em $0$. Assim, o comando \verb+A[1:3,1:4]+ retorna o bloco da matriz $A$ compreendido da segunda à terceira linha e da segunda a quarta coluna desta matriz.

\begin{ex}
Veja as seguintes linhas de comando:
\begin{lstlisting}
>>> B = np.random.random((4,4))
>>> B
array([[ 0.94313432,  0.72650883,  0.55487089,  0.18753526],
       [ 0.02094937,  0.45726099,  0.51925464,  0.8535878 ],
       [ 0.75948469,  0.95362926,  0.77942318,  0.06464183],
       [ 0.91243198,  0.22775889,  0.04061536,  0.14908227]])
>>> aux = np.copy(B[:,2])
>>> B[:,2] = np.copy(B[:,3])
>>> B[:,3] = np.copy(aux)
>>> B
array([[ 0.94313432,  0.72650883,  0.18753526,  0.55487089],
       [ 0.02094937,  0.45726099,  0.8535878 ,  0.51925464],
       [ 0.75948469,  0.95362926,  0.06464183,  0.77942318],
       [ 0.91243198,  0.22775889,  0.14908227,  0.04061536]])
\end{lstlisting}
\end{ex}

\subsection{Operações matriciais e elemento-a-elemento}

Em \verb+Julia+ com \verb+numpy+, o operador \verb+*+ opera elemento a elemento. Por exemplo:
\begin{lstlisting}
>>> A = np.array([[1,2],[2,1]]); print(A)
[[1 2]
 [2 1]]
>>> B = np.array([[2,1],[2,1]]); print(B)
[[2 1]
 [2 1]]
>>> print(A*B)
[[2 2]
 [4 1]]
\end{lstlisting}
A multiplicação matricial obtemos com:
\begin{lstlisting}
>>> C = A.dot(B)
>>> print(C)
[[6 3]
 [6 3]]
\end{lstlisting}

Aqui, temos as sintaxes análogas entre operações elemento-a-elemento:
\begin{lstlisting}
+ # adição
- # subtração
* # multiplicação
/ # divisão
^ # potenciação
\end{lstlisting}

\begin{ex}
  Veja as seguintes linhas de comando:
\begin{lstlisting}
>>> A = np.ones((2,2))
>>> A
array([[ 1.,  1.],
       [ 1.,  1.]])
>>> B = 2 * np.ones((2,2))
>>> B
array([[ 2.,  2.],
       [ 2.,  2.]])
>>> A*B
array([[ 2.,  2.],
       [ 2.,  2.]])
>>> A.dot(B)
array([[ 4.,  4.],
       [ 4.,  4.]])
>>> A/B
array([[ 0.5,  0.5],
       [ 0.5,  0.5]])
\end{lstlisting}
\end{ex}














\section{Gráficos}\index{Julia!gráficos}

Para criar um esboço do gráfico de uma função de uma variável real $y = f(x)$, podemos usar a biblioteca \verb+Julia+ \href{https://matplotlib.org/}{mathplotlib}.A função \verb+matplotlib.pyplot.plot+ faz uma representação gráfica de um conjunto de pontos $\{(x_i, y_i)\}$ fornecidos. Existe uma série de opções para esta função de forma que o usuário pode ajustar várias questões de visualização. Veja a \href{https://matplotlib.org/api/pyplot_api.html?highlight=pyplot.plot#matplotlib.pyplot.plot}{documentação}.

\begin{ex}
  Veja as seguintes linhas de código:
\begin{lstlisting}
>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> def f(x): return x**3 + 1
...
>>> x = np.linspace(-2,2)
>>> plt.plot(x, f(x))
[<matplotlib.lines.Line2D object at 0x7f4f6d153510>]
>>> plt.grid()
>>> plt.show()
\end{lstlisting}
\end{ex}
